require 'date'
class Array
  def next(item)
    i = (self.index(item) || -1) + 1
    return self[i % length]
  end
  def previous(item)
    i = (self.index(item) || length) -1
    return self[i % length]
  end
end
# Utilities for converting a date in various ways.
module DateUtils
  require 'date'
  # Attempts to convert the given string to a date. It can understand expressions like:
  #  * <em>today</em>
  #  * <em>next Tuesday</em>
  #  * <em>3 months</em>
  def DateUtils::convert_date(string)
    case string.downcase
    when /^today$/
      return Date.today
    when /^tomorrow$/
      return Date.today + 1
    when /^(?:next )?(\w+)$/
      day = Date::ABBR_DAYS[$1] || Date::DAYS[$1]
      raise unless day
      tod = Date.today
      tod=tod.succ while tod.wday != day
      return tod
    when /^(?:in\s*)?((?:[+-])?\d+)\s*(day|week|month|year)(s?)$/
      tod = Date.today
      no = $1.to_i
      case $2
      when "day"
        return tod + no
      when "week"
        return tod + no * 7
      when "month"
        return tod >> no
      when "year"
        return tod + no * 365
      end
    else
      return Date.parse(string.downcase)
    end
  end
  # Adds +days+ to the date described by +dateString+. +days+ can be negative.
  def DateUtils::addToDate(dateString,days)
    return Date.parse(dateString) + days
  end
  # Adds a month to the date described by +dateString+.
  def DateUtils::addMonth(dateString)
    return Date.parse(dateString) >> 1
  end
  # Subtracts a month from the date described by +dateString+.
  def DateUtils::subtractMonth(dateString)
    return Date.parse(dateString) << 1
  end
end
# The test <tt>date === DateLate</tt> returns true if +date+ is earlier than Date.today
class DateLate
  def self.===(date)
    date = Date.parse(date) unless Date === date
    return date < Date.today
  end
end
# A simple mixin that creates +uri+'s, +txmt+ uri schemes and +link+'s out of any object
# that responds to +file+, +line+ and +name+.
module Linkable
  def uri
    "file://#{self.file.to_s.gsub(/ /,"%20")}"
  end
  def txmt
    "txmt://open?url=#{self.uri}&line=#{self.line}"
  end
  def link(attributes = {})
    s = "<a href=\"#{self.txmt}\""
    attributes.each do |key,value|
      s << " #{key.to_s}=\"#{value.to_s}\""
    end
    s << ">#{self.name}</a>"
  end
end

# Very light logger class.
class MyLogger
  # Adds a string to the logs.
  def self.log(string)
    @@logs << string
  end
  # Dumps a string with all the logs.
  def self.dump
    @@logs.sort.join("\n")
  end
  # Clears the logs.
  def self.clear
    @@logs = []
  end
  self.clear
end
# A very-poor-man's Builder. Produces tables. Example of use:
#
#    pr = Printer.new
#    pr.table do
#      pr.title("Actions for context: #{context}")
#      pr.headers(["Action name","Project","Due_by"])
#      actions.each do |a|
#        proj = if a.project != nil then a.project.link else "none" end
#        due = case a.due
#          when "",nil
#            ""
#          when DateLate
#            "<span style=\"color:red\">#{a.due}</span>"
#          else
#            a.due
#        end
#        pr.row([a.link,proj,due])
#      end
#    return pr.to_html
class Printer
  # An array of items of the form +[:type,items]+, +items+ an array of strings.
  attr_accessor :items
  def initialize
    @items = []
  end
  # Adds caption to the table.
  def title(title)
    @items << [:title,title]
  end
  # Creates a table, with contents generated by yielding the block.
  def table
    @items << [:table_begin,nil]
    yield
    @items << [:table_end,nil]
  end
  # Adds headers to the table.
  def headers(*headers)
    @items << [:headers,*headers]
  end
  # Adds a row of items.
  def row(*row_items)
    @items << [:row,*row_items]
  end
  # Adds raw HTML code.
  def raw(code)
    @items << [:raw, code]
  end
  # Generate an HTML string out of the data that has been passed.
  def to_html
    s = []
    @items.each do |type,item|
      case type
        when :title
          s << "<caption>#{item}</caption>"
        when :table_begin
          s << "<table>"
        when :table_end
          s << "</table>"
        when :row
          s << "<tr>"
          s << item.map{|i| "<td>#{i}</td>"}.join("\n")
          s << "</tr>"
        when :headers
          s << "<tr>"
          s << item.map{|i| "<th>#{i}</th>"}.join("\n")
          s << "</tr>"
        when :raw
          s << item
      end
    end
    return s.join("\n")+"\n"
  end
end
